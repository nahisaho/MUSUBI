# MUSUBI - プロジェクト構造とアーキテクチャ

**バージョン**: 1.0
**最終更新**: 2025-11-16
**ステータス**: 計画フェーズ

---

## 概要

MUSUBIは、25の専門化されたClaude Code Skillsを構造化されたディレクトリ階層に整理した**スキルベースアーキテクチャ**に従います。プロジェクトは品質を強制するための**憲法ガバナンス**と、変更管理のための**デルタ仕様**を使用します。

---

## アーキテクチャパターン

### 1. スキルベースアーキテクチャ

**核心原則**: 機能はClaude Codeによってモデル呼び出しされる25の専門的で自律的なスキルに整理されます。

**スキルカテゴリ** (9カテゴリ):
- **オーケストレーションと管理** (3スキル): マスターコーディネーション、プロジェクトメモリ、ガバナンス
- **要件と計画** (3スキル): 要件分析、プロジェクト管理、変更影響分析
- **アーキテクチャと設計** (4スキル): システムアーキテクチャ、API設計、データベース設計、UI/UX設計
- **開発と実装** (2スキル): コード実装、AI/MLエンジニアリング
- **品質とレビュー** (5スキル): コードレビュー、バグハンティング、トレーサビリティ、セキュリティ、パフォーマンス
- **QA** (2スキル): テストエンジニアリング、品質保証
- **インフラと運用** (5スキル): DevOps、リリースコーディネーション、クラウドアーキテクチャ、SRE、データベース管理
- **ドキュメンテーション** (1スキル): テクニカルライティング

**パターン**: 各スキルは以下を含む自己完結型:
- YAMLフロントマター (name, description, trigger terms, allowed-tools)
- スキルプロンプト (責任、ワークフロー、テンプレート)
- 補助資料 (テンプレート、サンプル、ガイドライン)

### 2. 憲法ガバナンス

**核心原則**: すべての開発は、Phase -1 Gatesを通じて強制される9つの不変の憲法条項に準拠する必要があります。

**9つの憲法条項**:
1. **ライブラリファーストの原則**: すべての機能はライブラリとして始まる
2. **CLIインターフェース義務**: すべてのライブラリはCLIを公開する必要がある
3. **テストファーストの命令**: テストなしにコードはない (Red→Green→Blue)
4. **EARS要件フォーマット**: すべての要件はEARSパターンを使用
5. **トレーサビリティ義務**: 100%の要件↔設計↔コード↔テストマッピング
6. **プロジェクトメモリ**: スキルは作業前にステアリングをチェック
7. **シンプリシティゲート**: ≤3プロジェクト、将来の備えなし
8. **抽象化禁止ゲート**: フレームワークを直接使用、ラッパーなし
9. **統合ファーストテスティング**: 実サービス、契約必須

**強制**: `constitution-enforcer`スキルがこれらの条項に対してすべてのアーティファクトを検証します。

### 3. デルタ仕様システム

**核心原則**: 変更追跡を通じてグリーンフィールド (0→1) とブラウンフィールド (1→n) の両方のプロジェクトをサポート。

**パターン**:
- **グリーンフィールド**: `storage/specs/` に完全な仕様で開始
- **ブラウンフィールド**: 段階的な変更のために `storage/changes/` を使用
- **変更ワークフロー**: 提案 → 影響分析 → 実装 → アーカイブ
- **トレーサビリティ**: すべての変更はデルタファイルを介して元の仕様にリンク

**関連スキル**:
- `change-impact-analyzer`: 変更影響を分析
- `orchestrator`: 変更ワークフローを調整
- `traceability-auditor`: 変更カバレッジを検証

### 4. 自動更新プロジェクトメモリ (Steering)

**核心原則**: プロジェクトコンテキスト (アーキテクチャ、技術スタック、ビジネスドメイン) は自動的に維持され、すべてのスキルによって参照されます。

**ステアリングファイル**:
- `steering/structure.md`: アーキテクチャパターン、ディレクトリ構成、命名規則
- `steering/tech.md`: 技術スタック、フレームワーク、開発ツール
- `steering/product.md`: ビジネスコンテキスト、製品目的、ターゲットユーザー

**パターン**:
- `steering`スキルがコードベース分析から初期コンテキストを生成
- スキルがアーキテクチャ決定を行う際にステアリングを更新
- すべてのスキルは作業開始前にステアリングを読む (憲法条項VI)

**自動更新トリガー**:
| 完了したスキル | 更新内容 | ステアリングファイル |
|-----------------|---------|---------------|
| system-architect | アーキテクチャパターン | structure.md |
| api-designer | API規約 | tech.md |
| database-schema-designer | DBパターン | tech.md |
| cloud-architect | インフラパターン | tech.md + structure.md |
| ui-ux-designer | UIコンポーネント構成 | structure.md |
| software-developer | 新しい依存関係 | tech.md |

---

## ディレクトリ構成

### ルートディレクトリ構造

```
musubi/
├── .claude/                      # Claude Code統合
│   ├── skills/                   # 25スキル (モデル呼び出し)
│   └── commands/                 # スラッシュコマンド (ユーザー呼び出し)
├── steering/                     # プロジェクトメモリ (自動生成)
│   ├── structure.md              # このファイル
│   ├── tech.md                   # 技術スタック
│   ├── product.md                # ビジネスコンテキスト
│   └── rules/                    # ガバナンスルール
├── templates/                    # ドキュメントテンプレート
├── orchestration/                # マルチスキル調整パターン
├── validators/                   # 品質ゲート (Pythonスクリプト)
└── storage/                      # プロジェクトデータ
    ├── specs/                    # 現在の真実 (グリーンフィールド)
    ├── changes/                  # 変更提案 (ブラウンフィールド)
    └── features/                 # フィーチャーブランチ
```

### スキルディレクトリパターン

**場所**: `.claude/skills/[skill-name]/`

**標準構造**:
```
[skill-name]/
├── SKILL.md                      # YAMLフロントマターを含むメインスキル定義
├── [domain]-guide.md             # ドメイン固有のガイドライン
├── templates/                    # スキル固有のテンプレート
└── examples/                     # リファレンスサンプル
```

**例** (system-architect):
```
system-architect/
├── SKILL.md                      # アーキテクチャスキルプロンプト
├── c4-model-guide.md             # C4図標準
├── adr-template.md               # アーキテクチャ決定記録テンプレート
└── examples/
    └── sample-design.md
```

### コマンドディレクトリパターン

**場所**: `.claude/commands/`

**目的**: SDDワークフロー用のユーザー呼び出しスラッシュコマンド

**命名規則**: `sdd-[action].md`

**カテゴリ**:
- ワークフロー: `/sdd-requirements`, `/sdd-design`, `/sdd-tasks`, `/sdd-implement`
- 変更管理: `/sdd-change-init`, `/sdd-change-apply`, `/sdd-change-archive`
- 検証: `/sdd-validate-requirements`, `/sdd-validate-design`, `/sdd-validate-traceability`
- ユーティリティ: `/sdd-list`, `/sdd-show`

### ストレージディレクトリパターン

**場所**: `storage/`

**目的**: バージョン管理されたプロジェクトデータ

**サブディレクトリ**:
1. **specs/** - グリーンフィールド仕様 (現在の真実)
   ```
   specs/
   └── [capability]/
       ├── spec.md                # EARS要件
       └── design.md              # アーキテクチャ設計
   ```

2. **changes/** - ブラウンフィールド変更追跡
   ```
   changes/
   ├── [change-id]/
   │   ├── proposal.md            # 変更提案
   │   ├── tasks.md               # 実装計画
   │   ├── design.md              # 設計更新
   │   └── impact-analysis.md     # 影響評価
   └── archive/                   # 完了した変更
   ```

3. **features/** - フィーチャーブランチ仕様
   ```
   features/
   └── [feature-id]/
       ├── requirements.md        # EARS要件
       ├── research.md            # 技術調査
       ├── design.md              # アーキテクチャ
       └── tasks.md               # 実装計画
   ```

---

## 命名規則

### スキル

**パターン**: `lowercase-hyphenated-name` (小文字ハイフン区切り)

**例**:
- `requirements-analyst`
- `system-architect`
- `site-reliability-engineer`
- `change-impact-analyzer`

**ファイル**: スキルディレクトリ内の `SKILL.md` (大文字)

### スラッシュコマンド

**パターン**: `sdd-[action].md`

**例**:
- `sdd-requirements.md`
- `sdd-validate-traceability.md`
- `sdd-change-init.md`

### ステアリングファイル

**パターン**: `lowercase.md` (英語プライマリ), `lowercase.ja.md` (日本語翻訳)

**例**:
- `structure.md` / `structure.ja.md`
- `tech.md` / `tech.ja.md`
- `product.md` / `product.ja.md`

### ドキュメントテンプレート

**パターン**: 説明的な小文字名

**例**:
- `requirements.md` (EARS要件テンプレート)
- `design.md` (C4 + ADRテンプレート)
- `tasks.md` (P-ラベル付きタスクテンプレート)
- `proposal.md` (変更提案テンプレート)

---

## オーケストレーションパターン

### パターン1: 自動選択

**ユースケース**: ユーザーが高レベルの意図を提供し、オーケストレーターが適切なスキルを選択

**フロー**:
```
ユーザー意図 → オーケストレーター分析 → スキル選択 → 実行 → 結果返却
```

**例**: "ユーザー認証の要件を作成"
→ オーケストレーターが `requirements-analyst`スキルを選択

### パターン2: シーケンシャルワークフロー

**ユースケース**: マルチステージSDDワークフロー (8ステージ)

**フロー**:
```
調査 → 要件 → 設計 → タスク → 実装 → テスト → デプロイ → モニタリング
```

**関連スキル**: オーケストレーターがシーケンシャル実行を調整

### パターン3: 並列実行

**ユースケース**: 同時実行可能な独立したタスク

**フロー**:
```
オーケストレーター → P-ラベル付きタスクに分割 → 並列実行 → 結果マージ
```

**例**: P1 (API設計), P2 (DBスキーマ), P3 (UI設計) を同時実行

### パターン4: ネストされた委譲

**ユースケース**: サブオーケストレーションを必要とする複雑なドメイン

**フロー**:
```
オーケストレーター → ドメインオーケストレーターに委譲 → 専門スキル実行
```

**例**: クラウドデプロイは`cloud-architect`に委譲され、インフラスキルを調整

### パターン5: Human-in-the-Loop

**ユースケース**: ユーザー承認を必要とする品質ゲート

**フロー**:
```
スキル実行 → 検証ゲート → ユーザー承認 → 続行/拒否
```

**例**: 実装前の憲法検証

---

## 設計決定

### ADR-001: モノリシックエージェントではなくスキルベースアーキテクチャ

**ステータス**: 承認済み
**日付**: 2025-11-16

**背景**: シンプルさ (musuhiの20エージェント) と完全性 (全8SDDステージのカバレッジ) のバランスが必要。

**決定**: 明確なドメイン境界を持つ25の専門スキルを採用。

**理由**:
- モジュール性: 各スキルは独立してテスト・保守可能
- スケーラビリティ: 既存スキルに影響を与えずに新しいスキルを追加可能
- 発見可能性: YAMLトリガータームが自動スキル選択を可能に
- ガバナンス: スキルは憲法条項に対して個別に検証可能

**結果**:
- ポジティブ: 明確な関心の分離、保守の容易性
- ネガティブ: オーケストレーションの複雑さ増加 (オーケストレータースキルで軽減)

### ADR-002: スキルとしての憲法ガバナンス

**ステータス**: 承認済み
**日付**: 2025-11-16

**背景**: すべてのスキルにわたって一貫して品質ゲートを強制する必要がある。

**決定**: 検証のための専用`constitution-enforcer`スキルを作成。

**理由**:
- 一元化: 憲法準拠の単一真実源
- 自動化: 検証は手動ではなく自動化
- トレーサビリティ: すべての検証はログ記録され監査可能
- 分離: 強制ロジックは実装スキルから分離

**結果**:
- ポジティブ: 一貫した強制、手動チェック不要
- ネガティブ: 追加のスキル保守 (受け入れ可能なトレードオフ)

### ADR-003: 静的ドキュメントではなく自動更新ステアリング

**ステータス**: 承認済み
**日付**: 2025-11-16

**背景**: プロジェクトコンテキスト (アーキテクチャ、技術スタック) は時間とともに変化し、手動更新はエラーが発生しやすい。

**決定**: `steering`スキルがスキル実行に基づいてコンテキストを自動更新。

**理由**:
- 正確性: プロジェクトメモリがコードベースと同期を保つ
- 鮮度: 常に現在の状態を反映
- 自己文書化: アーキテクチャ決定が自動的にキャプチャ
- 準拠: 憲法条項VI (プロジェクトメモリ) をサポート

**結果**:
- ポジティブ: 常に正確、陳腐化したドキュメントなし
- ネガティブ: 慎重なトリガー設計が必要 (更新ルールで軽減)

---

## 統合ポイント

### Claude Code Skills API

**統合タイプ**: モデル呼び出しスキル

**メカニズム**:
- スキルは`.claude/skills/[name]/SKILL.md`で定義
- YAMLフロントマターに自動発見用のトリガータームを含む
- Claude Codeはユーザー意図分析に基づいてスキルを呼び出す

**例**:
```yaml
---
name: requirements-analyst
description: |
  要件分析、仕様書作成、ユーザーストーリー作成にこのスキルを使用します。

  トリガータム: requirements, specifications, user stories, acceptance criteria, EARS format
allowed-tools: [Read, Write, Glob, Grep]
---
```

### MCPサーバー

**統合タイプ**: スキルによる直接ツール呼び出し

**利用可能なMCPサーバー**:
- **context7**: 最新のライブラリドキュメンテーション
- **ide**: VS Code診断、Jupyterカーネル実行

**使用パターン**:
```
スキル → mcp__context7__get-library-docs("/vercel/next.js") → 最新Next.jsドキュメント
```

**専用MCPスキルなし**: スキルはMCPツールを直接呼び出します (理由はMCP-MANAGEMENT-ANALYSIS.mdを参照)

### Gitワークフロー

**統合タイプ**: すべてのアーティファクトのバージョン管理

**パターン**:
- すべての仕様、設計、タスクはGit追跡
- 変更提案はGitブランチ
- トレーサビリティはGit履歴を通じて維持
- 憲法検証はpre-commitフックとして実行

---

## 品質ゲート

### Phase -1 Gates (実装前)

**強制者**: `constitution-enforcer`スキル

**ゲート**:
1. **シンプリシティゲート**: ≤3プロジェクト、推測的機能なしを検証
2. **抽象化禁止ゲート**: 不要なラッパーをチェック
3. **統合ファーストゲート**: 実サービステストを保証
4. **EARS準拠ゲート**: すべての要件がEARSフォーマットを使用することを検証
5. **トレーサビリティゲート**: 100%要件カバレッジを確認
6. **ステアリング整合性ゲート**: プロジェクトメモリとの一貫性を検証

**トリガー**: 実装開始前

### 検証スクリプト

**場所**: `validators/`

**スクリプト**:
- `ears-format.py`: EARS構文検証
- `constitutional.py`: Phase -1 Gates強制
- `coverage.py`: 要件カバレッジ分析
- `traceability.py`: トレーサビリティマトリックス検証
- `delta-format.py`: デルタ仕様検証
- `consistency.py`: クロスアーティファクト一貫性

**実行**: 手動またはCI/CD経由で実行可能

---

## 進化と保守

### 新しいスキルの追加

1. スキルディレクトリを作成: `.claude/skills/[new-skill-name]/`
2. YAMLフロントマターでSKILL.mdを作成
3. 発見用のトリガータームを追加
4. オーケストレーター選択マトリックスを更新
5. steering/structure.md (このファイル) に追加
6. 必要に応じて憲法検証を更新

### アーキテクチャパターンの変更

1. 変更提案を通じて提案 (storage/changes/)
2. `change-impact-analyzer`スキルで影響を分析
3. 影響を受けるスキルを更新
4. steering/structure.mdを更新
5. `constitution-enforcer`で検証
6. 提案をアーカイブ

### パターンの非推奨化

1. steering/structure.mdで非推奨としてマーク
2. 移行パスを提供
3. 新しいパターンを使用するようにスキルを更新
4. 移行期間後に非推奨パターンを削除

---

## 参考文献

- **ブループリント**: Ultimate-SDD-Tool-Blueprint-v3-25-Skills.md
- **プロジェクト計画**: PROJECT-PLAN-MUSUBI.md
- **スキルインベントリ**: SKILLS-AUDIT-REPORT.md
- **MCP分析**: MCP-MANAGEMENT-ANALYSIS.md
- **憲法ガバナンス**: steering/rules/constitution.md (作成予定)
- **SDDワークフロー**: steering/rules/workflow.md (作成予定)

---

**ドキュメントオーナー**: steeringスキル
**保守者**: 自動更新ルール + 手動レビュー
**レビュー頻度**: 月次またはアーキテクチャ変更発生時
